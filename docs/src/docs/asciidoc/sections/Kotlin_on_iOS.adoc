= Kotlin on iOS

Kotlin Multiplattform hat einen anderen Ansatz als beispielsweise
ReactNative oder Flutter: Während sich mit diesen Frameworks vor allem
User Interfaces für verschiedene Platformen bauen lassen, überlässt KMP
genau das dem nativen Code. Das ermöglicht nicht nur, auf jeder
Plattform alle Möglichkeiten zu nutzen, es erlaubt auch, insbesondere auf
Apple Platform, die freie Wahl des Frameworks: KMP arbeitet genau so gut
mit UIKit zusammen wie mit SwiftUI. Technisch stellt sich auf iOS Seite
der Kotlin Multiplattform Teil als Cocoapods Dependency dar, und der
Kotlin Code wird direkt aus Xcode gebaut — es ist nicht notwendig, erst
mit einer anderen Toolchain eine Library ohne ähnliches zu bauen. Das
ermöglicht es auch den iOS Entwickler:innen, schnell und einfach
Änderungen am Kotlin Code vorzunehmen, und selbst zu testen, und
möglicherweise ins Repository zurückzuschreiben. Technisch wird KMP als
eine CocoaPods Dependency in ein Xcode Projekt eingefügt. Beim Anlegen
eines KMP Projekts im Android Studio wird auch ein Xcode Workspace
erzeugt, im Prinzip kann aber auch ein bestehender oder anderer
Workspace den Kotlin Code integrieren. Das bedeutet auch, dass die Xcode
Dateien völlig unabhängig von der Android Version sind, und somit
beliebig umbenannt oder verändert werden können. Die vom Kotlin Code
bereitgestellten Interfaces lassen sich aus Swift direkt aufrufen, und
auch problemlos in SwiftUI Integrieren. Es können also zum Beispiel im
Shared Kotlin Code direkt ViewModels erzeugt werden, um dann
entsprechend angezeigt zu werden. Kotlin Multiplattform Code muss aber
nicht immer gleich sein: Selbst in der geteilten Bibliothek kann es einen
unterschiedlichen Code für Android und iOS geben, der dann trotzdem mit
einem einheitlichen API an die jeweiligen Plattformen weitergegeben
wird. Das ist insbesondere deshalb interessant da hier im iOS Teil auch
auf Apple Frameworks zugegriffen werden kann. Beispielsweise wäre es
möglich, mit Kotlin für iOS schon mit den System Frameworks von iOS
lokalisierte Zeit und Datumsangaben zu übergeben, während das auf
Android mit den entsprechenden Frameworks funktioniert. Aber hier hören
die Möglichkeiten nicht auf: Es lassen sich sogar für den Kotlin Code
native Bibliotheken für iOS mit CocoaPods einbinden, und dann mit Kotlin
aufrufen. Dies erlaubt es, auch bei klarer Trennung der Aufgaben
plattformspezifisch im gemeinsamen Code zu arbeiten. Wer sich die
Integration etwas genauer ansieht, stellt fest, dass Kotlin in der Apple
Welt noch über eine Objective-C Brücke integriert wird. Während es damit
zwar auch möglich wäre, Kotlin aus einer Objective-C App aufzurufen, ist
der Hauptgrund vermutlich, dass das Swift Application Binary Interface
(ABI), dass also die Schnittstelle zu Swift definiert, vor noch nicht
allzu langer Zeit nicht stabil war, sondern sich noch regelmäßig
geändert hat. Ob es in der Zukunft ein wirklich natives Interface zu
Swift geben wird, ist noch unklar. Das erzeugt an manchen Stellen etwas
Reibung: Kotlin Coroutines werden auf iOS als Funktionen mit einer
Closure umgesetzt, da Objective-C dieses Konzept von asynchronen
Funktionen nicht kennt. Wer möchte, kann diese Funktionen natürlich in
Swift in Combine Publisher, oder auch als Async/Await Funktionen
verpacken. Damit aber auch Cancellations aus dem Kotlin Code an Swift
übergeben werden können, ist ein Plugin nötig, das die entsprechende
Funktionalität von Kotlin über Objective-C in Swift transportiert.
Kotlin Multiplattform ist extrem flexibel, und wirkt auf jeder Platform
heimisch. Durch eine sehr aktive Community und die Unterstützung von
JetBrains ist zu erwarten, dass dies in den kommenden Jahren noch besser
wird.
