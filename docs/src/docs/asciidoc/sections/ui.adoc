= UI

Wie es aus dem Architekturbild ersichtlich ist, Block zuständig für die Bedienoberfläche benannt CommonUI, nutzt gemeinsames Code geschrieben in Kotlin am alle Platformen, die Jetpack Compose in einer von den unterstützten Variante unterstützt. Wir haben als erstes die IoT Explorer App für Desktop als JVM gebaut und mit einer Variante für MacOS X experimentiert.

== ViewModel

ViewModels haben sich als eine perfekte Begleitung für reaktive Bedienoberflächen erwiesen. Das gilt nicht nur für Jetpack Compose, sondern genau so für SwiftUI. Als Implementierung haben wir zum Kotlin Multiplatform Konzept von expect/actual gegriffen, siehe <CODE 2> und <CODE 3>. So ist es zum Beispiel möglich für Android eine native Variante zu nutzen, die Application Lifecycle berücksichtigt.

CODE 2 ViewModel
[source,kotlin]
----
expect open class CommonViewModel() {
    val clientScope: CoroutineScope
    protected open fun onCleared()
}
----


.ViewModel on Android
[source,kotlin]
----
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.CoroutineScope

actual open class CommonViewModel actual constructor() : ViewModel() {
    actual val clientScope: CoroutineScope = viewModelScope
    actual override fun onCleared() {
        super.onCleared()
    }
}
----

Es hat sich als eine gute Idee erwiesen, die ViewModels so definieren, dass der Konstruktor sehr wenig oder keine Parameter hat, um eine Möglichkeit zu haben, die ViewModel Objekte auch in den Composable Funktionen zu instanziieren. Dabei hat sich _dependency injection_ als ein gangbarer Weg ergeben, um notwendige Objekte in ViewModels zu referenzieren. Hier können wir den Vorteil nutzen, dass Kotlin und Kotlin Multiplatform auch von einer wunderbaren Community leben und somit könnten wir __Koin__<LINK 8>, als ein Kotlin Multiplatform fähiges Framework einsetzen.

== Unidirectional Data Flow

Reaktive Oberflächen leben davon, dass die Daten in der UI nur in einer Richtung laufen, sich die Anzeige anhand der Deklaration durch Recomposition wieder anpasst und die neue UI gerendert wird. Wie können wir aber die Daten verändern oder wie gehen wir mit Benutzereingaben oder UI Ereignissen um? Wenn wir bei der IoT Explorer App bleiben: Um den Zustand eines Gerätes, zum Beispiel einen Schalter aktivieren oder um die Rollladen im Smarthome runterzufahren, muss entsprechendes Kommando über ein Protokoll, welches das Gerät versteht, geschickt werden. Das ist deutlich mehr, als eine Bedienoberfläche wissen sollte. In diesem Fall nutzen wir wieder ein weiters Konzept aus der Clean Architecture, den UseCase. Die Implementierung davon lebt wieder in der Domain Schicht, hat kein Wissen über der Bedienoberfläche und muss nur das Object kennen, das mit dem Gerät kommuniziert. Im <BILD 4> ist die Kommunikation grafisch dargestellt.

.<BILD 4> Data flow
image::unidirectional_dia.png[]
