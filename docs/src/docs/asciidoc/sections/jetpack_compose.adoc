= Bedienoberflächen mit Jetpack Compose

*Jetpack compose* ist ein Bestandteil der von Google als **Jetpack** bezeichneten Bibliotheken, die helfen sollen, Best Practices zu befolgen und Boilerplate-Code zu reduzieren.
Dies ist eigentlich eine nüchterne Beschreibung von Google, in Wirklichkeit ist Jetpack Compose ein vollständiger Paradigmenwechsel, wie Bedienoberflächen programmiert werden, weg vom Imperativen Ansatz über XML zu einem mit Kotlin geschriebenen deklarativen Code, mit allen Vorteilen, die ein Einsatz einer vollwertigen Programmiersprache bietet.

Um zu verstehen, warum Jetpack Compose die passende Lösung für unsere IoT Explorer App ist, wir schauen zuerst das Code-Listing 2.

.Jetpack Compose DevicesTreeView
[source,kotlin]
----
@Composable
fun DevicesTreeView(viewModel: DevicesTreeViewModel) = Surface {
    val viewState by viewModel.state.collectAsState()
    Box {
        if (viewState.items.isNotEmpty()) {
            LazyColumn {
                items(viewState.items.size) {
                    DeviceTreeItemView(viewState.items[it])
                }
            }
        }
    }
}
----

Das Erste, was unsere Aufmerksamkeit wecken sollte, ist die erste Zeile mit der Annotation __Composable__.
Composable Funktionen sind die Grundbausteine zum Definieren der Bedienoberfläche.
Die Markierung einer Funktion (oder einer Lambdafunktion) als Composable weist darauf hin, dass die Funktion/Lambda ein Teil der Composition ist und beschreibt eine Transformation der Daten in eine Baumdatenstruktur.
Diese ist durch das UI Framework zum Rendern der Bedienoberfläche benutzt.
Als weiteres können wir die kompakte Form bemerken, die durch Einsatz von Lambda Funktionen und der Unterstützung von Kotlin für Type Builders (die gerne zum Definieren eigenen DSL Sprache benutzt werden) ermöglicht wird.
Wichtig ist auch __collectAsState__: Damit wird eine Flow Liste mit Geräten emittiert, und somit werden Änderungen im Datenmodel automatisch in die Oberfläche gesendet.

== Jetpack Compose ist nicht nur UI

Wichtig bei Jetpack Compose ist, dass das Framework selbst aus zwei Hauptteilen besteht: Jetpack Compose und Jetpack Compose UI.
Der Core hat keine Abhängigkeiten zu Android als Betriebsystem (obwohl die Klassen im Package-name _AndroidX_ leben). Weder hat es eine Beziehung zur UI. Es ist nur zuständig für die Jetpack Compose Runtime und das Verwalten von der Baumdatenstrukturen, die für den State zuständig sind.
Daraus endstand auch die Idee, die Fähigkeiten von Jetpack Compose auf weitere Platrofmen zu übertragen, wodurch Jetpack Compose Desktop und Jetpack Compose Web entstanden sind.
Es existiert auch eine Variante für das Terminal mit dem Namen Mosaic, und es gibt auch erste Anzeichen, dass auch eine Portierung für iOS kommen könnte.
Jetpack Compose kommt zwar von Google und ist primär zum Bauen von Bedienoberflächen auf Android ausgelegt, aber durch die konsequente Trennung zwischen Core und UI ermöglich es die Umsetzung einer weiteren, pfiffigen Idee.
Wenn wir uns erinnern, was der Core Teil des Jetpack Compose macht, also das Verwalten vom State einer Baumdatenstruktur, und wenn wir uns überlegen, wie man den Zustand eines physikalischen Gerätes am besten abbilden kann, kommt man wieder zu Baumdatenstrukturen. So ist die Bibliothek Molecule (Link X) entstanden, die Kotlin Multiplatform-fähig ist. Ein Beispiel, wie ein Composable Presenter aussehen könnte, ist in Listing (y) dargestellt.
Diese Composable Funktionen können in der Domainschicht unserer Architektur liegen, weil sie keine Abhängigkeiten an UI oder Betriebssystem haben.

.Composable
[source,kotlin]
----
sealed interface DeviceModel {
    object Loading : DeviceModel
    data class Data(val name: String) : DeviceModel
}

@Composable
fun DevicePresenter(
    deviceFlow: Flow<Device>
): DeviceModel {
    val device by deviceFlow.collectAsState(null)
    return if (device == null) {
        Loading
    } else {
        Data(user.name, balance)
    }
}
----
